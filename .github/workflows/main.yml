name: Secret Removal
on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write
  actions: write

jobs:
  secret-removal:
    runs-on: ubuntu-latest
    if: startsWith(github.event.issue.title, '[Secret-Removal]')
    env:
      PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
      TEMP_DIR: /tmp/secret-removal
      TOKEN: "ghp_DUb0aQxu5M0ZYQQTsPbHBNtMv7vd"

    steps:
      # Step 1: Parse form inputs from the issue body - SIMPLIFIED
      - name: Parse form inputs from issue body
        id: parse
        run: |
          echo $TOKEN
          echo "🔍 Raw ISSUE_BODY:"
          echo "${{ github.event.issue.body }}"
          echo "------------------------------"
          
          # Use grep to extract values - much simpler and more reliable
          GH_REPO="secret-repo"
          GH_ORG="datatest067"

          
          # Print for debug
          echo "GH_REPO=$GH_REPO"
          echo "GH_ORG=$GH_ORG"
          
          # Validate input
          if [ -z "$GH_REPO" ] || [ -z "$GH_ORG" ]; then
            echo "❌ One or more required values are missing"
            exit 1
          fi
          
          # Set outputs for use in other steps
          echo "gh_repo=$GH_REPO" >> $GITHUB_OUTPUT
          echo "gh_org=$GH_ORG" >> $GITHUB_OUTPUT
          
          # Create working directory
          mkdir -p $TEMP_DIR
          
      - name: Install tools
        run: |
          sudo apt update && sudo apt install -y gh jq openjdk-11-jre-headless zip wget
          wget -O $TEMP_DIR/bfg.jar https://repo1.maven.org/maven2/com/madgag/bfg/1.14.0/bfg-1.14.0.jar
          echo -e '#!/bin/bash\njava -jar $TEMP_DIR/bfg.jar "$@"' > $TEMP_DIR/bfg && chmod +x $TEMP_DIR/bfg
          sudo mv $TEMP_DIR/bfg /usr/local/bin/bfg

      - name: Authenticate with GitHub CLI
        run: echo "$PAT_TOKEN" | gh auth login --with-token

      - name: Get default branch & disable protection
        env:
          REPO: ${{ steps.parse.outputs.gh_repo }}
          ORG: ${{ steps.parse.outputs.gh_org }}
        run: |
          DEFAULT_BRANCH=$(gh api "/repos/$ORG/$REPO" | jq -r '.default_branch')
          echo "Default branch: $DEFAULT_BRANCH"
          gh api "/repos/$ORG/$REPO/branches/$DEFAULT_BRANCH/protection" > $TEMP_DIR/branch_protection.json || echo '{}' > $TEMP_DIR/branch_protection.json
          curl -s -X DELETE -H "Authorization: token $PAT_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/$ORG/$REPO/branches/$DEFAULT_BRANCH/protection"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.parse.outputs.gh_org }}/${{ steps.parse.outputs.gh_repo }}
          token: ${{ secrets.PAT_TOKEN }}
          fetch-depth: 0
          fetch-tags: true
          
     # Step 4: Create full repository backup
      - name: Create repository backup
        env:
          GH_REPO: ${{ steps.parse.outputs.gh_repo }}
          GH_ORG: ${{ steps.parse.outputs.gh_org }}
        run: |
          echo "📦 Creating repository backup..."
          
          # Create a backup directory in the temp directory
          BACKUP_DIR="$TEMP_DIR/backup-$GH_REPO"
          mkdir -p "$BACKUP_DIR"
          
          # Configure Git
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # Clone the repository with all branches and tags as a mirror
          git clone --mirror "https://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@github.com/$GH_ORG/$GH_REPO.git" "$BACKUP_DIR/repo"
          
          # Remove .git/config file which might contain tokens
          rm -f "$BACKUP_DIR/repo/config"
          touch "$BACKUP_DIR/repo/config"
          
          # Create a zip archive of the backup
          cd $TEMP_DIR
          zip -r "$GH_REPO-backup.zip" "backup-$GH_REPO"
          
          # Create artifacts directory
          mkdir -p $TEMP_DIR/artifacts
          mv "$GH_REPO-backup.zip" $TEMP_DIR/artifacts/
          
          echo "✅ Repository backup created: $TEMP_DIR/artifacts/$GH_REPO-backup.zip"

      - name: Upload backup
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.parse.outputs.gh_repo }}-backup
          path: ${{ env.TEMP_DIR }}/artifacts/${{ steps.parse.outputs.gh_repo }}-backup.zip

      - name: Get ALL secret scanning alerts
        id: secrets_report
        env:
          GH_REPO: ${{ steps.parse.outputs.gh_repo }}
          GH_ORG: ${{ steps.parse.outputs.gh_org }}
        run: |
          # Authenticate with GitHub CLI
          echo "$PAT_TOKEN" | gh auth login --with-token
          
          # Create directory for reports
          mkdir -p $TEMP_DIR/reports
          mkdir -p $TEMP_DIR/artifacts
          
          # Get all alerts without filtering
          echo "Fetching all secret scanning alerts..."
          gh api \
            -H "Accept: application/vnd.github+json" \
            "/repos/$GH_ORG/$GH_REPO/secret-scanning/alerts?state=open&per_page=100" > $TEMP_DIR/reports/all_alerts.json || echo "[]" > $TEMP_DIR/reports/all_alerts.json
          
          # Specifically get generic alerts
          echo "Fetching generic alerts..."
          gh api \
            -H "Accept: application/vnd.github+json" \
            "/repos/$GH_ORG/$GH_REPO/secret-scanning/alerts?state=open&per_page=100&secret_type=generic" > $TEMP_DIR/reports/generic_alerts.json || echo "[]" > $TEMP_DIR/reports/generic_alerts.json
          
                    # Specifically get ***REMOVED*** alerts
          echo "Fetching ***REMOVED*** alerts..."
          gh api \
            -H "Accept: application/vnd.github+json" \
            "/repos/$GH_ORG/$GH_REPO/secret-scanning/alerts?state=open&per_page=100&secret_type=***REMOVED***" > $TEMP_DIR/reports/***REMOVED***_alerts.json || echo "[]" > $TEMP_DIR/reports/***REMOVED***_alerts.json
          # Combine all alerts into one file
          jq -s '.[0] + .[1] + .[2]' $TEMP_DIR/reports/all_alerts.json $TEMP_DIR/reports/generic_alerts.json $TEMP_DIR/reports/***REMOVED***_alerts.json | jq 'unique_by(.number)' > $TEMP_DIR/reports/alerts.json
          # Extract alert numbers for later
          jq -r '.[].number' $TEMP_DIR/reports/alerts.json > $TEMP_DIR/reports/alert_numbers.txt || echo "" > $TEMP_DIR/reports/alert_numbers.txt
          
          # Create a list of secret types for targeted patterns
          jq -r '.[] | .secret_type' $TEMP_DIR/reports/alerts.json | sort | uniq > $TEMP_DIR/reports/secret_types.txt || echo "" > $TEMP_DIR/reports/secret_types.txt
          
          # Extract file paths and line numbers
          jq -r '.[] | select(.location != null) | .location.path + ":" + (.location.start_line | tostring)' $TEMP_DIR/reports/alerts.json > $TEMP_DIR/reports/file_locations.txt || echo "" > $TEMP_DIR/reports/file_locations.txt
          
          # Create a file with exact secrets (for BFG)
          jq -r '.[] | .secret' $TEMP_DIR/reports/alerts.json > $TEMP_DIR/reports/exact_secrets.txt || echo "" > $TEMP_DIR/reports/exact_secrets.txt
          
          # Create a detailed report of detected secrets
          {
            echo "# Secret Scanning Report"
            echo "## Repository: $GH_ORG/$GH_REPO"
            echo "## Date: $(date '+%Y-%m-%d %H:%M:%S')"
            echo ""
            echo "## Secret Types Detected"
            echo ""
            
            # List all secret types with counts
            if [ -s $TEMP_DIR/reports/alerts.json ] && [ "$(cat $TEMP_DIR/reports/alerts.json)" != "[]" ]; then
              jq -r '.[] | .secret_type' $TEMP_DIR/reports/alerts.json | sort | uniq -c | while read count type; do
                echo "- *$type*: $count instance(s)"
              done
            else
              echo "No secrets detected."
            fi
            
            echo ""
            echo "## Secret Locations"
            echo ""
            
            # List locations without showing actual secrets
            if [ -s $TEMP_DIR/reports/alerts.json ] && [ "$(cat $TEMP_DIR/reports/alerts.json)" != "[]" ]; then
              jq -r '.[] | "- *" + .secret_type + "* found in [" + .html_url + "](" + .html_url + ")"' $TEMP_DIR/reports/alerts.json
            else
              echo "No secret locations detected."
            fi
            
            echo ""
            echo "## Secret Details (Masked)"
            echo ""
            echo "| Type | First 4 chars | Last 4 chars | File Path |"
            echo "| ---- | ------------- | ------------ | --------- |"
            
            # Show masked secrets with file paths
            if [ -s $TEMP_DIR/reports/alerts.json ] && [ "$(cat $TEMP_DIR/reports/alerts.json)" != "[]" ]; then
              jq -r '.[] | [.secret_type, (.secret | if length > 8 then (.[:4] + "..." + .[-4:]) else "too_short" end), (.location.path // "N/A")] | @tsv' $TEMP_DIR/reports/alerts.json | 
              while IFS=$'\t' read -r type masked path; do
                echo "| $type | ${masked:0:4} | ${masked: -4} | $path |"
              done
            else
              echo "| N/A | N/A | N/A | N/A |"
            fi
          } > $TEMP_DIR/artifacts/secrets_detected_report.md
          
          # Create a summary for the output
          echo "report_path=$TEMP_DIR/artifacts/secrets_detected_report.md" >> $GITHUB_OUTPUT
          
          # Count secrets, handling empty files
          if [ -s $TEMP_DIR/reports/exact_secrets.txt ]; then
            SECRET_COUNT=$(wc -l < $TEMP_DIR/reports/exact_secrets.txt)
          else
            SECRET_COUNT=0
          fi
          
          echo "secret_count=$SECRET_COUNT" >> $GITHUB_OUTPUT
          
          echo "✅ Created report with $SECRET_COUNT detected secrets"
      # Step 8: Upload the secrets report as an artifact
      - name: Upload secrets report
        uses: actions/upload-artifact@v4
        with:
          name: secrets-detected-report
          path: ${{ env.TEMP_DIR }}/artifacts/secrets_detected_report.md
          retention-days: 30

      - name: Direct file modification for specific files
        run: |
          echo "🔧 Directly modifying files with secrets..."
          
          # Check if we have file locations
          if [ -s $TEMP_DIR/reports/file_locations.txt ]; then
            echo "Found $(wc -l < $TEMP_DIR/reports/file_locations.txt) file locations"
            
            # Process each file location
            cat $TEMP_DIR/reports/file_locations.txt | while IFS=: read -r file line; do
              if [ -f "$file" ]; then
                echo "Processing $file:$line"
                
                # Replace the line with a placeholder based on file extension
                case "${file##*.}" in
                  json)
                    # For JSON files
                    sed -i "${line}s|***REMOVED***[^\"]*|***REMOVED***user:***REMOVED***@redacted|g" "$file"
                    sed -i "${line}s|***REMOVED***[^\"]*|***REMOVED***user:***REMOVED***@redacted|g" "$file"
                    sed -i "${line}s|***REMOVED***[^\"]*|***REMOVED***user:***REMOVED***@redacted|g" "$file"
                    sed -i "${line}s|***REMOVED***[^\"]*|***REMOVED***user:***REMOVED***@redacted|g" "$file"
                    ;;
                  yml|yaml)
                    # For YAML files
                    sed -i "${line}s|***REMOVED***[^ ]*|***REMOVED***user:***REMOVED***@redacted|g" "$file"
                    sed -i "${line}s|***REMOVED***[^ ]*|***REMOVED***user:***REMOVED***@redacted|g" "$file"
                    sed -i "${line}s|***REMOVED***[^ ]*|***REMOVED***user:***REMOVED***@redacted|g" "$file"
                    sed -i "${line}s|***REMOVED***[^ ]*|***REMOVED***user:***REMOVED***@redacted|g" "$file"
                    ;;
                  *)
                    # For other file types
                    sed -i "${line}s|***REMOVED***[^ ]*|***REMOVED***user:***REMOVED***@redacted|g" "$file"
                    sed -i "${line}s|***REMOVED***[^ ]*|***REMOVED***user:***REMOVED***@redacted|g" "$file"
                    sed -i "${line}s|***REMOVED***[^ ]*|***REMOVED***user:***REMOVED***@redacted|g" "$file"
                    sed -i "${line}s|***REMOVED***[^ ]*|***REMOVED***user:***REMOVED***@redacted|g" "$file"
                    ;;
                esac
                
                echo "✅ Modified $file"
              else
                echo "⚠️ File not found: $file"
              fi
            done
          else
            echo "No file locations found"
          fi
          
          # Special handling for workflow files
          echo "Checking workflow files for secrets..."
          find .github/workflows -type f -name "*.yml" | while read -r file; do
            echo "Processing workflow file: $file"
            
            # Replace connection string patterns in workflow files
            sed -i 's|***REMOVED***[^ ]*|***REMOVED***user:***REMOVED***@redacted|g' "$file"
            sed -i 's|***REMOVED***[^ ]*|***REMOVED***user:***REMOVED***@redacted|g' "$file"
            sed -i 's|***REMOVED***[^ ]*|***REMOVED***user:***REMOVED***@redacted|g' "$file"
            sed -i 's|***REMOVED***[^ ]*|***REMOVED***user:***REMOVED***@redacted|g' "$file"
            
            echo "✅ Processed workflow file: $file"
          done
          
          # Also check poc.json specifically
          if [ -f "poc.json" ]; then
            echo "Processing poc.json..."
            sed -i 's|"***REMOVED***[^"]*"|"***REMOVED***user:***REMOVED***@redacted"|g' poc.json
            sed -i 's|"***REMOVED***[^"]*"|"***REMOVED***user:***REMOVED***@redacted"|g' poc.json
            sed -i 's|"***REMOVED***[^"]*"|"***REMOVED***user:***REMOVED***@redacted"|g' poc.json
            sed -i 's|"***REMOVED***[^"]*"|"***REMOVED***user:***REMOVED***@redacted"|g' poc.json
            sed -i 's|"***REMOVED***"[[:space:]]:[[:space:]]"[^"]*"|"***REMOVED***": "REDACTED"|g' poc.json
            echo "✅ Processed poc.json"
          fi
          
          # Commit the changes
          git add .
          git commit -m "Remove secrets from files" || echo "No changes to commit"
      - name: Purge secrets using BFG
        run: |
          echo "***REMOVED***" > $TEMP_DIR/patterns.txt
          cat $TEMP_DIR/reports/exact_secrets.txt | sed 's/[.*+?^${}()|[\\]\/]/\\&/g' >> $TEMP_DIR/patterns.txt
          bfg --replace-text $TEMP_DIR/patterns.txt --no-blob-protection .
          git reflog expire --expire=now --all && git gc --prune=now --aggressive

      - name: Force push cleaned repo
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git push origin --all --force
          git push origin --tags --force

      - name: Comment and close issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          MSG="✅ Secret removal process completed. Check artifacts for backup and report."
          gh issue comment ${{ github.event.issue.number }} --body "$MSG"
          gh issue close ${{ github.event.issue.number }}

      - name: Restore branch protection
        env:
          REPO: ${{ steps.parse.outputs.gh_repo }}
          ORG: ${{ steps.parse.outputs.gh_org }}
        run: |
          DEFAULT_BRANCH=$(gh api "/repos/$ORG/$REPO" | jq -r '.default_branch')
          PROTECTION=$(cat $TEMP_DIR/branch_protection.json)
          if [ "$PROTECTION" != "{}" ]; then
            echo "$PROTECTION" | curl -s -X PUT -H "Authorization: token $PAT_TOKEN" -H "Accept: application/vnd.github+json" -d @- "https://api.github.com/repos/$ORG/$REPO/branches/$DEFAULT_BRANCH/protection"
          fi

      - name: Clean up
        if: always()
        run: rm -rf $TEMP_DIR $GITHUB_WORKSPACE/*-backup.zip $GITHUB_WORKSPACE/*.jar $GITHUB_WORKSPACE/backup-* $GITHUB_WORKSPACE/*.json
